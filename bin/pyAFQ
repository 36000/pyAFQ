#!/usr/bin/env python

import warnings
import os.path as op
import os
import pathlib
import datetime
import platform
import toml
from ast import literal_eval

from funcargparse import FuncArgParser
from argparse import ArgumentParser, FileType

with warnings.catch_warnings():
    warnings.simplefilter("ignore")

    print("Loading AFQ libraries...")

    import AFQ
    import AFQ.api as api
    from AFQ.utils.bin import get_default_args
    import AFQ.segmentation as seg
    import AFQ.tractography as aft

    import logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger('pyAFQ')

usage = \
    f"""pyAFQ /path/to/afq_config.ini

Runs full AFQ processing as specified in the configuration file.

For details about configuration, see instructions in:
https://yeatmanlab.github.io/pyAFQ/usage.html#running-the-pyafq-pipeline

The default configuration file looks like:

"""


def process_defaults(defaults_dict):
    defaults_list = []
    for k, v in defaults_dict.items():
        if isinstance(v, str):
            defaults_list.append(f"{k} = '{v}'")
        elif isinstance(v, bool):
            if v:
                defaults_list.append(f"{k} = true")
            else:
                defaults_list.append(f"{k} = false")
        elif callable(v):
            defaults_list.append(f"{k} = '{v.__name__}'")
        else:
            defaults_list.append(f"{k} = {v}")
    return defaults_list


def _val_to_toml(v):
    if v is None:
        return "''"
    if isinstance(v, str):
        return f"'{v}'"
    elif isinstance(v, bool):
        if v:
            return "true"
        else:
            return "false"
    elif callable(v):
        return f"'{v.__name__}'"
    else:
        return f"{v}"


def _dict_to_toml(dictionary):
    toml = ''
    for section, args in dictionary.items():
        toml = toml + f'[{section}]\n'
        for arg, arg_info in args.items():
            toml = toml + '\n'
            if isinstance(arg_info, dict):
                toml = toml + arg_info['desc']
                toml = toml + f"{arg} = {_val_to_toml(arg_info['default'])}\n"
            else:
                toml = toml + f"{arg} = {_val_to_toml(arg_info)}\n"
        toml = toml + '\n'
    return toml + '\n'


def parse_cli(help_msg):
    cli_parser = ArgumentParser(usage=usage + _dict_to_toml(arg_dict))

    cli_parser.add_argument(
        dest='config',
        action="store",
        help="Path to config file. For example, /path/to/afq_config.toml")

    cli_parser.add_argument(
        '-g',
        '--generate-config-only',
        dest='generate_toml',
        action="store_true",
        default=False,
        help="Generate a default config file at the path"
        + " specified without running pyAFQ.")

    cli_parser.add_argument(
        '-o',
        '--overwrite-config',
        dest='overwrite',
        action="store_true",
        default=False,
        help="Overwrite config file at the path"
        + " with current arguments and comments,"
        + " preserving previous defaults when applicable.")

    cli_parser.add_argument(
        '-t', '--notrack', action="store_true", default=False,
        help="Disable the use of pyAFQ being recorded by Google Analytics. ")

    opts = cli_parser.parse_args()

    if not opts.notrack:
        logger.info(
            "Your use of pyAFQ is being recorded using Google Analytics. "
            "For more information, please refer to the pyAFQ documentation: "
            "https://yeatmanlab.github.io/pyAFQ/usage.html#usage-tracking-with-google-analytics. "  # noqa
            "To turn this off, use the `--notrack` flag when using the pyAFQ CLI")
        import popylar
        popylar.track_event(AFQ._ga_id, "pyAFQ_cli", "CLI called")

    return opts.config, opts.generate_toml, opts.overwrite


def _func_dict_to_arg_dict(func_dict):
    arg_dict = {}
    for name, func in func_dict.items():
        docstr_parser = FuncArgParser()
        docstr_parser.setup_args(func)
        for arg, info in docstr_parser.unfinished_arguments.items():
            try:
                if name == "AFQ":
                    if '_params' in arg:
                        continue
                    section, desc = info['help'].split('[')[1].split(']')
                else:
                    section = name.upper()
                    desc = info['help']
            except KeyError:
                logger.warning(
                    "We are missing a valid description for the "
                    + f"{name} argument {arg}")
                continue
            if section not in arg_dict.keys():
                arg_dict[section] = {}
            arg_dict[section][arg] = {}
            if 'default' in info:
                default = info['default']
            else:
                default = None
            arg_dict[section][arg]['default'] = default
            arg_dict[section][arg]['desc'] = ''
            for desc_line in desc.splitlines():
                f_desc_line = '# ' + desc_line.strip() + '\n'
                arg_dict[section][arg]['desc'] = \
                    arg_dict[section][arg]['desc'] + f_desc_line

    return arg_dict


def generate_config(toml_file, default_arg_dict, overwrite=False):
    if not overwrite and op.exists(toml_file):
        raise FileExistsError(
    "Config file already exists. "
    + "If you want to overwrite this file,"
    + " add the argument --overwrite-config")
    logger.info("Generating default configuration file.")
    toml_file = open(toml_file, 'w')
    toml_file.write(_dict_to_toml(default_arg_dict))


def parse_config_run_afq(toml_file, default_arg_dict, overwrite=False):
    # load configuration file
    if not op.exists(toml_file):
        raise FileExistsError(
    "Config file does not exist. "
    + "If you want to generate this file,"
    + " add the argument --generate-config-only")
    f_arg_dict = toml.load(toml_file)

    # extract arguments from file
    kwargs = {}
    bids_path = ''
    for section, args in f_arg_dict.items():
        for i, arg_default_pair in enumerate(args):
            for arg, default in arg_default_pair.items():
                default_arg_dict[section][arg]['default'] = default
                if arg == 'bids_path':
                    bids_path = default
                else:
                    if default == "''":
                        kwargs[arg] = None
                    else:
                        kwargs[arg] = default

    # if overwrite, write new file with updated docs / args
    if overwrite:
        logger.info(f"Updating configuration file.")
        with open(toml_file, 'w') as ff:
            ff.write(_dict_to_toml(default_arg_dict))

    if bids_path == '':
        raise RuntimeError("Config file must provide bids_path")

    # generate metadata file for this run
    default_arg_dict['pyAFQ'] = {}
    default_arg_dict['pyAFQ']['utc_time_started'] = \
        datetime.datetime.now().isoformat('T')
    default_arg_dict['pyAFQ']['version'] = AFQ.__version__
    default_arg_dict['pyAFQ']['platform'] = platform.system()

    afq_path = op.join(bids_path, 'derivatives', 'afq')
    os.makedirs(afq_path, exist_ok=True)

    afq_metadata_file = op.join(afq_path, 'afq_metadata.toml')
    with open(afq_metadata_file, 'w') as ff:
        ff.write(_dict_to_toml(default_arg_dict))

    myafq = api.AFQ(bids_path, **kwargs)

    # Do all the things:
    myafq.set_dti_cfa()
    myafq.set_dti_pdd()
    myafq.set_template_xform()
    if kwargs["segmentation_params"] is None\
            or "seg_algo" not in kwargs["segmentation_params"]\
            or kwargs["segmentation_params"]["seg_algo"].lower() == "afq":
        myafq.export_rois()
        myafq.viz_ROIs(export_as_gif=True)
        myafq.viz_bundles(export_as_gif=True)
        myafq.plot_tract_profiles()
    myafq.export_bundles()
    myafq.combine_profiles()

    # If you got this far, you can report on time ended and record that:
    default_arg_dict['pyAFQ']['utc_time_ended'] = datetime.datetime.now().isoformat('T')
    with open(afq_metadata_file, 'w') as ff:
        ff.write(_dict_to_toml(default_arg_dict))


if __name__ == '__main__':
    func_dict = {
        "AFQ": api.AFQ.__init__,
        "Tractography": aft.track,
        "Segmentation": seg.Segmentation.__init__,
        "Cleaning": seg.clean_bundle}

    arg_dict = _func_dict_to_arg_dict(func_dict)
    config_file, generate_only, overwrite = parse_cli(arg_dict)
    if generate_only:
        generate_config(config_file, arg_dict, overwrite)
    else:
        parse_config_run_afq(config_file, arg_dict, overwrite)
