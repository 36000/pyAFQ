#!/usr/bin/env python

import warnings
import os.path as op
import os
import pathlib
import datetime
import platform
import toml

from argparse import ArgumentParser

with warnings.catch_warnings():
    warnings.simplefilter("ignore")

    print("Loading AFQ libraries...")

    import AFQ
    import AFQ.api as api
    from AFQ.utils.bin import func_dict_to_arg_dict, dict_to_toml

    import logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger('pyAFQ')

usage = \
    f"""pyAFQ /path/to/afq_config.ini

Runs full AFQ processing as specified in the configuration file.

For details about configuration, see instructions in:
https://yeatmanlab.github.io/pyAFQ/usage.html#running-the-pyafq-pipeline

The default configuration file looks like:

"""


def parse_cli(help_msg):
    cli_parser = ArgumentParser(usage=usage + dict_to_toml(arg_dict))

    cli_parser.add_argument(
        dest='config',
        action="store",
        help="Path to config file. For example, /path/to/afq_config.toml")

    cli_parser.add_argument(
        '-g',
        '--generate-config-only',
        dest='generate_toml',
        action="store_true",
        default=False,
        help="Generate a default config file at the path"
        + " specified without running pyAFQ.")

    cli_parser.add_argument(
        '-o',
        '--overwrite-config',
        dest='overwrite',
        action="store_true",
        default=False,
        help="Overwrite config file at the path"
        + " with current arguments and comments,"
        + " preserving previous defaults when applicable.")

    cli_parser.add_argument(
        '-t', '--notrack', action="store_true", default=False,
        help="Disable the use of pyAFQ being recorded by Google Analytics. ")

    opts = cli_parser.parse_args()

    if not opts.notrack:
        logger.info(
            "Your use of pyAFQ is being recorded using Google Analytics. "
            "For more information, please refer to the pyAFQ documentation: "
            "https://yeatmanlab.github.io/pyAFQ/usage.html#usage-tracking-with-google-analytics. "  # noqa
            "To turn this off, use the `--notrack` flag when using the pyAFQ CLI")
        import popylar
        popylar.track_event(AFQ._ga_id, "pyAFQ_cli", "CLI called")

    return opts.config, opts.generate_toml, opts.overwrite


def generate_config(toml_file, default_arg_dict, overwrite=False):
    if not overwrite and op.exists(toml_file):
        raise FileExistsError(
    "Config file already exists. "
    + "If you want to overwrite this file,"
    + " add the argument --overwrite-config")
    logger.info("Generating default configuration file.")
    toml_file = open(toml_file, 'w')
    toml_file.write(dict_to_toml(default_arg_dict))


def parse_config_run_afq(toml_file, default_arg_dict, overwrite=False):
    # load configuration file
    if not op.exists(toml_file):
        raise FileExistsError(
    "Config file does not exist. "
    + "If you want to generate this file,"
    + " add the argument --generate-config-only")
    f_arg_dict = toml.load(toml_file)

    # extract arguments from file
    kwargs = {}
    bids_path = ''
    for section, args in f_arg_dict.items():
        for arg, default in args.items():
            if section not in default_arg_dict:
                default_arg_dict[section] = {}
            if arg == 'bids_path':
                bids_path = default
            elif arg in default_arg_dict[section]:
                if default == "''":
                    kwargs[arg] = None
                else:
                    kwargs[arg] = default
            if arg not in default_arg_dict[section]:
                default_arg_dict[section][arg] = {}
            default_arg_dict[section][arg]['default'] = default

    # if overwrite, write new file with updated docs / args
    if overwrite:
        logger.info(f"Updating configuration file.")
        with open(toml_file, 'w') as ff:
            ff.write(dict_to_toml(default_arg_dict))

    if bids_path == '':
        raise RuntimeError("Config file must provide bids_path")

    # generate metadata file for this run
    default_arg_dict['pyAFQ'] = {}
    default_arg_dict['pyAFQ']['utc_time_started'] = \
        datetime.datetime.now().isoformat('T')
    default_arg_dict['pyAFQ']['version'] = AFQ.__version__
    default_arg_dict['pyAFQ']['platform'] = platform.system()

    afq_path = op.join(bids_path, 'derivatives', 'afq')
    os.makedirs(afq_path, exist_ok=True)

    afq_metadata_file = op.join(afq_path, 'afq_metadata.toml')
    with open(afq_metadata_file, 'w') as ff:
        ff.write(dict_to_toml(default_arg_dict))

    myafq = api.AFQ(bids_path, **kwargs)

    # Do all the things:
    myafq.set_dti_cfa()
    myafq.set_dti_pdd()
    myafq.set_template_xform()
    if kwargs["segmentation_params"] is None\
            or "seg_algo" not in kwargs["segmentation_params"]\
            or kwargs["segmentation_params"]["seg_algo"].lower() == "afq":
        myafq.export_rois()
        myafq.viz_ROIs(export_as_gif=True)
        myafq.viz_bundles(export_as_gif=True)
        myafq.plot_tract_profiles()
    myafq.export_bundles()
    myafq.combine_profiles()

    # If you got this far, you can report on time ended and record that:
    default_arg_dict['pyAFQ']['utc_time_ended'] = datetime.datetime.now().isoformat('T')
    with open(afq_metadata_file, 'w') as ff:
        ff.write(dict_to_toml(default_arg_dict))


if __name__ == '__main__':
    arg_dict = func_dict_to_arg_dict(logger=logger)
    config_file, generate_only, overwrite = parse_cli(arg_dict)
    if generate_only:
        generate_config(config_file, arg_dict, overwrite)
    else:
        parse_config_run_afq(config_file, arg_dict, overwrite)
