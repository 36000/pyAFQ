#!/usr/bin/env python

import warnings
import os.path as op
import os
import pathlib
import datetime
import platform
from ast import literal_eval

from funcargparse import FuncArgParser
from argparse import ArgumentParser, FileType
from configupdater import ConfigUpdater
# from cli2gui import Cli2Gui

with warnings.catch_warnings():
    warnings.simplefilter("ignore")

    print("Loading AFQ libraries...")

    import AFQ
    import AFQ.api as api
    from AFQ.utils.bin import get_default_args
    import AFQ.segmentation as seg
    import AFQ.tractography as aft

    import logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger('pyAFQ')

# These options were used to make cli2gui video
# use_config_gui = True
# bin_folder = pathlib.Path(__file__).parent.absolute()
# gui_image = op.join(bin_folder, "../example_image.png")
# gui_background_color = "#ffffcc"
# gui_text_color = "#663300"
# gui_input_box_color = "#ffffff"
# gui_button_color = "#ffff66"
# gui_theme = \
#     [gui_button_color, "#ffffff", "#ffffff", "#ffffff", "#ffffff",
#      "#ffffff", gui_text_color, "#ffffff", "#ffffff", "#ffffff",
#      "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff", "#ffffff",
#      gui_background_color, gui_input_box_color, "#ffffff", "#ffffff",
#      "#ffffff", "#ffffff", "#ffffff", "#ffffff"]
# gui_sizes = \
#     {"title_size": 36,  # room for title
#      "label_size": (58, None),  # room for text
#      "input_size": (24, 1),  # width by height of input button
#      "button": (12, 1),
#      "padding": (5, 10),
#      "helpText_size": 2,  # flaky, may interfere with buttons
#      "text_size": 16}  # text size of buttons

usage = \
    f"""pyAFQ /path/to/afq_config.ini

Runs full AFQ processing as specified in the configuration file.

For details about configuration, see instructions in:
https://yeatmanlab.github.io/pyAFQ/usage.html#running-the-pyafq-pipeline

The default configuration file looks like:

"""


def process_defaults(defaults_dict):
    defaults_list = []
    for k, v in defaults_dict.items():
        if isinstance(v, str):
            defaults_list.append(f"{k} = '{v}'")
        elif isinstance(v, bool):
            if v:
                defaults_list.append(f"{k} = true")
            else:
                defaults_list.append(f"{k} = false")
        elif callable(v):
            defaults_list.append(f"{k} = '{v.__name__}'")
        else:
            defaults_list.append(f"{k} = {v}")
    return defaults_list


def _val_to_toml(v):
    if v is None:
        return "''"
    if isinstance(v, str):
        return f"'{v}'"
    elif isinstance(v, bool):
        if v:
            return "true"
        else:
            return "false"
    elif callable(v):
        return f"'{v.__name__}'"
    else:
        return f"{v}"

def _toml_to_val(v):
    if v == '':
        return None
    if v[0] == "'" and v[-1] == "'":
        return v[1:-1]
    elif v == "true":
        return True
    elif v == "false":
        return False
    elif '.' in v:
        return float(v)
    else:
        return int(v)

def _dict_to_toml(dictionary):
    toml = ''
    for section, args in dictionary.items():
        toml = toml + f'[{section}]\n'
        for arg, arg_info in args.items():
            toml = toml + '\n'
            toml = toml + arg_info['desc']
            toml = toml + f"{arg} = {_val_to_toml(arg_info['default'])}\n"
        toml = toml + '\n'
    return toml + '\n'


def _toml_to_dict(toml):
    return {}


def parse_cli(help_msg):
    # cli_parser parses user arguments from CLI
    cli_parser = ArgumentParser(usage=usage + _dict_to_toml(arg_dict))

    cli_parser.add_argument(
        dest='config',
        action="store",
        # type=FileType('r'),
        help="Path to config file. For example, /path/to/afq_config.ini")

    cli_parser.add_argument(
        '-t', '--notrack', action="store_true", default=False,
        help="Disable the use of pyAFQ being recorded by Google Analytics. ")

    opts = cli_parser.parse_args()

    if not opts.notrack:
        logger.info(
            "Your use of pyAFQ is being recorded using Google Analytics. "
            "For more information, please refer to the pyAFQ documentation: "
            "https://yeatmanlab.github.io/pyAFQ/usage.html#usage-tracking-with-google-analytics. "  # noqa
            "To turn this off, use the `--notrack` flag when using the pyAFQ CLI")
        import popylar
        popylar.track_event(AFQ._ga_id, "pyAFQ_cli", "CLI called")

    return opts.config


def _func_dict_to_arg_dict(func_dict):
    arg_dict = {}
    for name, func in func_dict.items():
        docstr_parser = FuncArgParser()
        docstr_parser.setup_args(func)
        for arg, info in docstr_parser.unfinished_arguments.items():
            try:
                if name == "AFQ":
                    if '_params' in arg:
                        continue
                    section, desc = info['help'].split('[')[1].split(']')
                else:
                    section = name.upper()
                    desc = info['help']
            except KeyError:
                logger.warning(
                    "We are missing a valid description for the "
                    + f"{name} argument {arg}")
                continue
            if section not in arg_dict.keys():
                arg_dict[section] = {}
            arg_dict[section][arg] = {}
            if 'default' in info:
                default = info['default']
            else:
                default = None
            arg_dict[section][arg]['default'] = default
            arg_dict[section][arg]['desc'] = ''
            for desc_line in desc.splitlines():
                f_desc_line = '# ' + desc_line.strip() + '\n'
                arg_dict[section][arg]['desc'] = \
                    arg_dict[section][arg]['desc'] + f_desc_line

    return arg_dict


def parse_config_run_afq(config_file, doc_args, cli_args):
    # cfparser parses the config .ini file
    cfparser = ConfigUpdater()
    if not op.exists(config_file):
        logger.info(f"Configuration file did not exist; created.")
        open(config_file, 'w').close()
    cfparser.read(config_file)

    # iterate over all arguments in docstring
    for arg, info in doc_args.items():
        try:
            section, desc = info['help'].split('[')[1].split(']')
        except KeyError:
            continue

        # updates any arguments not currently in .ini
        if not cfparser.has_option(section, arg):
            if not cfparser.has_section(section):
                cfparser.add_section(section)
            if 'default' in info and info['default'] is not None:
                default = info['default']
            else:
                default = "''"
            logger.info(f"{arg} added to configuration file.")
            cfparser[section][arg] = default

            for desc_line in desc.splitlines():
                cfparser[section][arg].add_before.comment(
                    desc_line, comment_prefix=';')

        # use command line arguments to set new defaults
        if arg in cli_args:
            new_default = getattr(cli_args, arg)
            if new_default is not None:
                logger.info(
                    f"{arg} set to {new_default} in configuration file.")
                cfparser[section][arg] = new_default

    # update metadata section of config file
    if not cfparser.has_section('METADATA'):
        cfparser.add_section('METADATA')
    cfparser['METADATA']['utc_time_started'] = \
        datetime.datetime.now().isoformat('T')
    cfparser['METADATA']['version'] = AFQ.__version__
    cfparser['METADATA']['platform'] = platform.system()

    cfparser.update_file()

    # read updated arguments from cfparser
    kwargs = {}
    for section in cfparser.sections():
        if section == 'METADATA':
            continue
        for option in cfparser.options(section):
            val = cfparser[section][option].value
            if val == "''":
                val = None
            logger.info(f"{option} set to {val}")
            try:
                val = literal_eval(val)
            except (ValueError, SyntaxError):
                pass
            if option == 'bids_path':
                bids_path = val
                afq_path = op.join(bids_path, 'derivatives', 'afq')
                os.makedirs(afq_path, exist_ok=True)
            else:
                kwargs[option] = val

    myafq = api.AFQ(bids_path, **kwargs)

    # Do all the things:
    myafq.set_dti_cfa()
    myafq.set_dti_pdd()
    myafq.set_template_xform()
    if kwargs["segmentation_params"] is None\
            or "seg_algo" not in kwargs["segmentation_params"]\
            or kwargs["segmentation_params"]["seg_algo"].lower() == "afq":
        myafq.export_rois()
        myafq.viz_ROIs(export_as_gif=True)
        myafq.viz_bundles(export_as_gif=True)
        myafq.plot_tract_profiles()
    myafq.export_bundles()
    myafq.combine_profiles()

    # If you got this far, you can report on time ended and record that:
    cfparser['METADATA']['utc_time_ended'] = datetime.datetime.now().isoformat('T')
    cfparser.update_file()


if __name__ == '__main__':
    func_dict = {
        "AFQ": api.AFQ.__init__,
        "Tractography": aft.track,
        "Segmentation": seg.Segmentation.__init__,
        "Cleaning": seg.clean_bundle}

    arg_dict = _func_dict_to_arg_dict(func_dict)
    config_file = parse_cli(arg_dict)
    parse_config_run_afq(config_file, arg_dict, {})
