import nibabel as nib
import numpy as np
from time import time
import os.path as op

from AFQ.definitions.utils import StrInstantiatesMixin, find_file
from AFQ._fixes import ConformedAffineMap
import AFQ.registration as reg
import AFQ.data as afd

try:
    from fsl.data.image import Image
    from fsl.transform.fnirt import readFnirt
    from fsl.transform.nonlinear import applyDeformation
    has_fslpy = True
except ModuleNotFoundError:
    has_fslpy = False

__all__ = ["FnirtMap", "SynMap", "SlrMap", "AffMap"]

# For map defintions, get_for_row should return only the mapping
# Where the mapping has transform and transform_inverse functions
# which each accept data, **kwargs


class FnirtMap(StrInstantiatesMixin):
    """
    Use an existing FNIRT map. Expects a warp file
    and an image file for each subject / session; image file
    is used as src space for warp.

    Parameters
    ----------
    warp_suffix : str
        suffix to pass to bids_layout.get() to identify the warp file.
    space_suffix : str
        suffix to pass to bids_layout.get() to identify the space file.
    warp_filters : str
        Additional filters to pass to bids_layout.get() to identify
        the warp file.
        Default: {}
    space_filters : str
        Additional filters to pass to bids_layout.get() to identify
        the space file.
        Default: {}


    Examples
    --------
    fnirt_map = FnirtMap(
        "warp",
        "MNI",
        {"scope"="TBSS"},
        {"scope"="TBSS"})
    api.AFQ(mapping=fnirt_map)
    """

    def __init__(self, warp_suffix, space_suffix,
                 warp_filters={}, space_filters={}):
        if not has_fslpy:
            raise ImportError(
                "Please install fslpy if you want to use FnirtMap")
        self.warp_suffix = warp_suffix
        self.space_suffix = space_suffix
        self.warp_filters = warp_filters
        self.space_filters = space_filters
        self.fnames = {}

    def find_path(self, bids_layout, from_path, subject, session):
        if session not in self.fnames:
            self.fnames[session] = {}

        nearest_warp = find_file(
            bids_layout, from_path, self.warp_filters, self.warp_suffix,
            session, subject)

        nearest_space = find_file(
            bids_layout, from_path, self.space_filters, self.space_suffix,
            session, subject)

        self.fnames[session][subject] = (nearest_warp, nearest_space)

    def get_for_row(self, afq_object, row):
        nearest_warp, nearest_space = self.fnames[row['ses']][row['subject']]

        our_templ = afq_object.reg_template_img
        subj = Image(row['dwi_file'])
        their_templ = Image(nearest_space)
        warp = readFnirt(nearest_warp, their_templ, subj)

        return FnirtMapping(warp, our_templ.affine)


class FnirtMapping():
    """
        FnirtMapping which matches the generic mapping API.
    """

    def __init__(self, warp, ref_affine):
        self.ref_affine = ref_affine
        self.warp = warp

    def transform_inverse(self, data, **kwargs):
        data_img = Image(nib.Nifti1Image(
            data.astype(np.float32), self.ref_affine))
        xform_data = np.asarray(applyDeformation(data_img, self.warp).data)
        return xform_data

    def transform(self, data, **kwargs):
        raise NotImplementedError(
            "Fnirt based mappings can currently"
            + " only transform from template to subject space")


class GeneratedMapMixin(object):
    """
    Helper Class
    Useful for maps that are generated by pyAFQ
    """

    def get_fnames(self, extension, afq_object, row):
        mapping_file = afq_object._get_fname(
            row,
            '_mapping_from-DWI_to_MNI_xfm')
        meta_fname = afq_object._get_fname(row, '_mapping_reg')
        mapping_file = mapping_file + extension
        meta_fname = meta_fname + '.json'
        return mapping_file, meta_fname

    def prealign(self, afq_object, row):
        prealign_file = afq_object._get_fname(
            row, '_prealign_from-DWI_to-MNI_xfm.npy')
        if not op.exists(prealign_file):
            reg_subject_img, _ = afq_object._reg_img(
                afq_object.reg_subject, True, row)
            start_time = time()
            _, aff = reg.affine_registration(
                reg_subject_img.get_fdata(),
                afq_object.reg_template_img.get_fdata(),
                reg_subject_img.affine,
                afq_object.reg_template_img.affine,
                **self.affine_kwargs)
            np.save(prealign_file, aff)
            meta_fname = afq_object._get_fname(
                row, '_prealign_from-DWI_to-MNI_xfm.json')
            meta = dict(type="rigid")
            afd.write_json(meta_fname, meta)
            row['timing']['Registration_pre_align'] =\
                row['timing']['Registration_pre_align'] + time() - start_time
        return prealign_file

    def get_for_row(self, afq_object, row):
        mapping_file, meta_fname = self.get_fnames(
            self.extension, afq_object, row)

        if self.use_prealign:
            reg_prealign = np.load(self.prealign(afq_object, row))
        else:
            reg_prealign = None
        if not op.exists(mapping_file):
            reg_template_img, reg_template_sls = \
                afq_object._reg_img(afq_object.reg_template, False, row)
            reg_subject_img, reg_subject_sls = \
                afq_object._reg_img(afq_object.reg_subject, True, row)

            start_time = time()
            mapping = self.gen_mapping(
                afq_object, row, reg_template_img, reg_template_sls,
                reg_subject_img, reg_subject_sls, reg_prealign)
            row['timing']['Registration'] =\
                row['timing']['Registration'] + time() - start_time

            reg.write_mapping(mapping, mapping_file)
            meta = dict(type="displacementfield")
            afd.write_json(meta_fname, meta)
        if self.use_prealign:
            reg_prealign_inv = np.linalg.inv(reg_prealign)
        else:
            reg_prealign_inv = None
        mapping = reg.read_mapping(
            mapping_file,
            row['dwi_file'],
            afq_object.reg_template_img,
            prealign=reg_prealign_inv)
        return mapping


class SynMap(StrInstantiatesMixin, GeneratedMapMixin):
    """
    Calculate a Syn registration for each subject/session
    using reg_subject and reg_template.

    Parameters
    ----------
    use_prealign : bool
        Whether to perform a liner pre-registration.
        Default: True
    affine_kwargs : dictionary, optional
        Parameters to pass to affine_registration
        in AFQ.registration, which does the linear pre-alignment.
        Only used if use_prealign is True.
        Default: {}
    Examples
    --------
    api.AFQ(mapping=SynMap())
    """

    def __init__(self, use_prealign=True, affine_kwargs={}):
        self.use_prealign = use_prealign
        self.affine_kwargs = affine_kwargs
        self.extension = ".nii.gz"

    def find_path(self, bids_layout, from_path, subject, session):
        pass

    def gen_mapping(self, afq_object, row, reg_template_img, reg_template_sls,
                    reg_subject_img, reg_subject_sls, reg_prealign):
        _, mapping = reg.syn_registration(
            reg_subject_img.get_fdata(),
            reg_template_img.get_fdata(),
            moving_affine=reg_subject_img.affine,
            static_affine=reg_template_img.affine,
            prealign=reg_prealign)
        if self.use_prealign:
            mapping.codomain_world2grid = np.linalg.inv(reg_prealign)
        return mapping


class SlrMap(StrInstantiatesMixin, GeneratedMapMixin):
    """
    Calculate a SLR registration for each subject/session
    using reg_subject and reg_template.


    Examples
    --------
    api.AFQ(mapping=SlrMap())
    """

    def __init__(self):
        self.use_prealign = False
        self.extension = ".npy"

    def find_path(self, bids_layout, from_path, subject, session):
        pass

    def gen_mapping(self, afq_object, row, reg_template_img, reg_template_sls,
                    reg_subject_img, reg_subject_sls, reg_prealign):
        return reg.slr_registration(
            reg_subject_sls, reg_template_sls,
            moving_affine=reg_subject_img.affine,
            moving_shape=reg_subject_img.shape,
            static_affine=reg_template_img.affine,
            static_shape=reg_template_img.shape)


class AffMap(StrInstantiatesMixin, GeneratedMapMixin):
    """
    Calculate an affine registration for each subject/session
    using reg_subject and reg_template.

    affine_kwargs : dictionary, optional
        Parameters to pass to affine_registration
        in AFQ.registration, which does the linear pre-alignment.
        Default: {}

    Examples
    --------
    api.AFQ(mapping=AffMap())
    """

    def __init__(self, affine_kwargs={}):
        self.use_prealign = False
        self.affine_kwargs = affine_kwargs
        self.extension = ".npy"

    def find_path(self, bids_layout, from_path, subject, session):
        pass

    def gen_mapping(self, afq_object, row, reg_template_img, reg_template_sls,
                    reg_subject_img, reg_subject_sls, reg_prealign):
        return ConformedAffineMap(np.load(self.prealign(afq_object, row)))
